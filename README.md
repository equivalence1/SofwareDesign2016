#Краткое описание архитектуры

Основной класс -- это `ShellImpl`. Для его конструирования ожидается
объект типа `AbstractCommandFactory` (туда/оттуда будут добавляться/браться
наши комманды). `OutputStream stdout` -- наш выходной поток, `InputStream
stdin` -- наш входной поток.

Основной метов -- `run`. В нем и происходит обработка и исполнение всех
команд пользователя.

Также `Shell` следит за текущей директорией.

Все команды лежат в пакете `commands`. Каждая команда должна реализовывать
интерфейс `Command` и быть проаннотированна аннотацией `CommandAnnotation`,
где будет задано имя этой команды. Наш `CommandFactory` регистрирует
(`CommandFactory#registerCommand`) только такие команды. Т.к. конструктор
`Command` сделан package-private, то юзер будет вынужден класть свои команды
в этот пакет.

Каждая команда обязана реализовать функцию `execute(InputStream in, Token[] args)`.

В целом происходит следующее: кто-то создает наш `ShellImpl`, этот `shell`
регистрирует в `commandFactory` команды, которые ему будут известны, потом
кто-то вызывает метод `run`. Тут мы считываем строчка за строчкой команды
пользователя. Очередная строка обрабатывается так -- `Tokenizer` разбивает
ее на токены, каждый из которых может быть какого-то из типов `TokenType`.
После этого, мы на этих токенах выполняем создание/подстановку переменных.
Затем все это опять склеиваем в строчку и опять токенизируем. После этого
уже начинаем непосредственно исполнение команд. Если такого имени команды
мы не знаем, то считаем это внешней командой. Последняя команда (несколько
команд могут соединяться пайпами) будет выводить в `stdout`.